#!/usr/bin/env python

# MIT License
# 
# Copyright 2021 Home Brew Robotics Club
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this
# software and associated documentation files (the "Software"), to deal in the Software
# without restriction, including without limitation the rights to use, copy, modify,
# merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to the following
# conditions:
#
# The above copyright notice and this permission notice shall be included in all or
# substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
# INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
# PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
# FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
# OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

# <====================================== 100 Characters ======================================= > #

import subprocess
import sys

from pathlib import Path
from typing import IO, List, Tuple

def main() -> int:
    # Parse command line arguments:
    args: List[str, ] = sys.argv[1:]
    # print(f"args={args}")
    if len(args) == 0:
        print(f"Usage: serial_agent.py [WORKSPACE_DIR] [PACKAGE_NAME]")

    workspace_directory: Path = Path("/tmp/dev_ws") if len(args) <= 1 else Path(args[0])
    package_name: str = "serial_agent" if len(args) <= 2 else args[1]
    # print(f"workspace_directory='{workspace_directory}' package_name='{package_name}'")

    # Create the various directories:
    ros2_package_directory: Path = workspace_directory / "src" / package_name
    python_package_directory: Path = ros2_package_directory / package_name
    python_package_directory.mkdir(parents=True, exist_ok=True)
        
    # Write out the `package.xml` and `__init__.py` files:
    package_xml_create(ros2_package_directory, package_name)
    init_py_create(python_package_directory)
    setup_cfg_create(ros2_package_directory, package_name)
    setup_py_create(ros2_package_directory, package_name)
    resource_create(ros2_package_directory, package_name)

    serial_agent_generator: SerialAgentGenerator = SerialAgentGenerator()
    # Temporary:
    serial_agent_generator.publisher_add("topic", "String")
    serial_agent_generator.subscription_add("topic", "String")
    serial_agent_generator.timer_add("event", "String", 0.5)
    serial_agent_generator.serial_agent_py_create(ros2_package_directory, package_name)
    return 0


class SerialAgentGenerator:
    """Class for generating a serial agent."""

    # SerialAgentGenerator.__init__():
    def __init__(self) -> None:
        """Initialize SerialAgentGenerator."""

        # Miscellaneous variables:
        triple_quote: str = '"' * 3

        # Copyright lines for the beginning of the file:
        self.copyright_lines: List[str] = [
            "# Code generated by ros2_serial_manager.py.",
            "# Generated code is not really covered by copyright law.",
        ]

        self.main_lines: List[str] = [
            "",
            "",
            "# main():",
            "def main(args: Optional[List[str]] = None) -> None:",
            "    # Initialize the Python ROS2 interface library.",
            "    rclpy.init(args=args)",
            "",
            "    # Create the serial agent Node:",
            "    serial_agent: SerialAgent = SerialAgent()",
            "",
            "    # Start the serial agent Node.  All activity occurs via callback routines:",
            "    print('Starting rclpy.spin()')",
            "    rclpy.spin(serial_agent)",
            "",
            "    # Destroy the serial agent node explicitly.",
            "    agent_node.destroy_node()",
            "",
            "    # Shut down the Python ROS2 interface library.",
            "    rclpy.shutdown()",
        ]

        # The standard import lines that do not change:
        self.start_import_lines: List[str] = [
            "",
            "# Type hint imports:",
            "from typing import Any, Dict, List, Optional",
            "",
            "# Rclpy imports:",
            "import rclpy",
            "from rclpy.client import Client",
            "from rclpy.impl.rcutils_logger import RcutilsLogger as Logger",
            "from rclpy.node import Node",
            "from rclpy.publisher import Publisher",
            "from rclpy.subscription import Subscription",
            "from rclpy.timer import Timer",
        ]

        # The message import lines:
        self.message_import_lines: List[str] = [
            "",
            "# Message Type imports:",
            "from std_msgs.msg import String",  # Temporary
        ]

        # The service import lines:
        self.service_import_lines: List[str] = [
            "",
            "# Service Type imports:",
            "from example_interfaces.srv import AddTwoInts",  # Temporary
        ]

        # Serial Agent class lines:
        self.class_header_lines: List[str] = [
            "",
            "# SerialAgent:",
            "class SerialAgent(Node):",
            f"    {triple_quote}Serial Agent for managing pulications/subscriptions{triple_quote}",
            "",
        ]

        self.init_start_lines: List [str] = [
            "",
            "    # SerialAgent.init():",
            "    def __init__(self) -> None:",
            f"        {triple_quote}Initialize SerialAgent class.{triple_quote}",
            "",
            "        # Initialize the Node super-class:",
            "        print('=>SerialAgent.__init__()')",
            "        super().__init__('serial_agent')",
        ]


        self.publisher_init_lines: List[str] = []
        self.timer_init_lines: List[str] =[]
        self.subscription_init_lines: List[str] = []

        # Callback methods are added to this list:
        self.callback_lines: List[str] = []

        # The boiler plate code to call main() goes here:
        self.main_call_lines: List[str] = [
            "",
            "",
            "if __name__ == '__main__':",
            "    main(args=None)",
        ]

    # SerialAgent.serial_agent_pyt_create():
    def serial_agent_py_create(self, ros2_package_directory: Path, package_name: str) -> None:
        """Write out `serial_agent.py` file."""
        triple_quote: str = '"' * 3

        all_import_lines: List[str] = (
            self.start_import_lines +
            self.message_import_lines +
            self.service_import_lines
        )

        all_init_lines: List[str] = (
            self.init_start_lines +
            self.publisher_init_lines +
            self.subscription_init_lines +
            self.timer_init_lines
        )

        # Join all of the lines that make up the class into *all_class_lines*:
        all_class_lines: List[str] = (
            self.class_header_lines +
            all_init_lines +
            self.callback_lines
        )

        # Join all the lines together into *all_lines* and create a single
        all_lines: List[str] = (
            self.copyright_lines +
            all_import_lines +
            self.main_lines +
            all_class_lines +
            self.main_call_lines +
            [""]  # Trick to get the final new-line on the file content
        )

        # Generate the `serial_agent.py` file:
        all_content: str = "\n".join(all_lines)
        serial_agent_py_path: Path = ros2_package_directory / package_name / "serial_agent.py"
        serial_agent_py_file: IO[str]
        with open(serial_agent_py_path, "w") as serial_agent_py_file:
            serial_agent_py_file.write(all_content)

    # SerialAgent.publisher_add():
    def publisher_add(self, topic_name: str, topic_type: str) -> None:
        """Add a publisher to the serial agent."""
        
        publisher_init_lines: List[str] = self.publisher_init_lines

        if not publisher_init_lines:
            publisher_init_lines.extend([
                "",
                "        # Create all topic pubishers here:",
                "        self.publishers_table: Dict[str, Publisher] = {}",
                "        self.publishers_counter: Dict[str, int] = {}",
                "        print('Publishing to {tuple(self.agent_publishers.names())}')",
            ])

        # Add publisher here:
        subscription_callback_name: str = f"{topic_name}_subscription_callback"
        publisher_init_lines.extend([
            f"        self.publishers_table['{topic_name}'] = self.create_publisher(",
            f"            {topic_type}, '{topic_name}', 10)",
            f"        self.publishers_counter['{topic_name}'] = 0",
        ])
            

    # SerialAgent.timer_add():
    def timer_add(self, topic_name: str, topic_type: str, period: float) -> None:
        """Add a timer callback."""

        # Ensure that the timers dictionary is created:
        timer_init_lines: List[str] = self.timer_init_lines
        if not timer_init_lines:
            timer_init_lines.extend([
                "",
                "        # Create all timers here:",
                "        self.timers_table: Dict[str, Timer] = {}",
                "        self.timers_counter: Dict[str, int] = {}",
            ])

        # Create the timer here:
        callback_name: str = f"{topic_name}_timer"
        timer_init_lines.extend([
            f"        self.timers_table['{topic_name}'] = (",
            f"            self.create_timer({period}, self.{callback_name}))",
            f"        self.timers_counter['{topic_name}'] = 0",
        ])
        
        # Create the callback counter and function:
        callback_lines: List[str] = self.callback_lines
        dq: str = "\""  # Double Quote
        dq3: str = dq * 3
        callback_lines.extend([
            "",
            f"    # SerialAgent.{callback_name}:",
            f"    def {callback_name}(self) -> None:",
            f"        {dq3}Callback for {topic_name} Timer.{dq3}",
            "",
            f"        count: int = self.timers_counter['{topic_name}']",
            f"        message: {topic_type} = {topic_type}()",
            f"        message.data = f'Counter={{count}}'",
            "",
            f"        # Temporary:",
            f"        publisher: Publisher = self.publishers_table['topic']",
            f"        publisher.publish(message)",
            f"        print('\\nTimer({dq}{topic_name}{dq}): '",
            f"              f'Publish {{message}} to Topic({dq}{topic_name}{dq})')",
            "",
            f"        self.timers_counter['{topic_name}'] = count + 1",
            f"        # print('<=SerialAgent.{callback_name}()')",
        ])

    # SerialAgent.subscrption_add():
    def subscription_add(self, topic_name: str, topic_type: str) -> None:
        """Add a subscription to the serial agent."""


        # Ensure that the subscriptions dictionary is initalized to empty:
        subscription_init_lines: List[str] = self.subscription_init_lines
        if not subscription_init_lines:
            self.subscription_init_lines.extend([
                "",
                "        # Create all Topic subscriptions here:",
                "        self.subscriptions_table: Dict[str, Subscription] = {}",
                "        self.subscriptions_counter: Dict[str, 0] = {}",
            ])

        # Create the subscription and add it to the subscriptions dictionary:
        callback_name: str = f"{topic_name}_subscription_callback"
        subscription_init_lines.extend([
            f"        self.subscriptions_table['{topic_name}'] = self.create_subscription(",
            f"            {topic_type}, '{topic_name}', self.{callback_name}, 10)",
            f"        self.subscriptions_counter['{topic_name}'] = 0",
        ])

        # Create the callback method for the subscription:
        dq: str = "\""
        dq3: str = dq * 3
        callback_lines: List[str] = self.callback_lines
        callback_lines.extend([
            "",
            f"    # SerialAgent.{callback_name}():",
            f"    def {callback_name}(self, message: {topic_type}) -> None:",
            f"        {dq3}Callback for '{topic_name}' topic subscription.{dq3}",
            "",
            f"        print(f'Subscription({dq}{topic_name}{dq}): Got {dq}{{message.data}}{dq}')",
        ])

# def serial_agent_py_create(python_package_directory: Path, package_name: str) -> None:
#    """Create serail agent python file."""
#    agent_lines: List[str] = []
#    agent_lines.extend([
#        "# Code generate by ros2_serial_manager.py.",
#        "# Generated code is not particularly copyrightable",
#        "",
#    ])
#
#    # Add message imports:
#    agent_lines.extend([
#        "from std_msgs.msg import String"
#        "",
#    ])
#
#    # Create AgentNode class:
#    agent_lines.extend([
#        "class AgentNode(Node):",
#        '    """Agent message/service/parameter transfer Node."""',
#        "",
#    ])
#    
#    # 
#    quote3: str = '"' * 3
#
#    # Create the AgentNode.__init__() method:
#    init_lines: List[str] = []
#    publisher_init_lines: List[str] = [
#        "",
#        "        # Register topic subscrptions:",
#    ]
#    publisher_callback_lines: List[str] = [
#        "",
#        "        # Register topic publishers :",
#    ]
#
#
#
#    subscription_init_lines: List[str] = []
#    subscription_callback_lines: List[str]  = []
#    
#    agent_lines.extend([
#        "    def __init__(self):",
#        f"        {quote3}Initalize AgentNode.{quote3}",
#        "        super().__init__('agent')",
#        "",
#        "        # Create the service availability checking timer:",
#        "        timer_period: float = 1.0",
#        "        self._service_timer: Timer = self.create_timer(timer_period)",
#        "",
#        "        # Register topic publishers:",
#        "        self._publications: Dict[str, Publisher] = {}",
#        "        self._publications['topic2'] = self.create_publisher(",
#        "            String, 'topic2', 10)",
#        "",
#        "        # Register topic subscriptions:",
#        "        self._subscriptions: Dict[str, Subscription] = {}",
#        "        self._subscriptions['topic'] = self.create_subscription(",
#        "            String, 'topic', self.callback1, 10)",
#        "        self._subscriptions['topic2'] = self.create_subscription(",
#        "            String, 'topic2', self.callback2, 10)",
#        "",
#        "        # Register service providers:",
#        "        self._service_providers",
#        "",
#        "        # Register service requests:",
#        "        self._pending_clients: Dict[int, Tuple[str, Client] = {}",
#        "        self._clients: Dict[int, Tuple[str, Client] = {}",
#        "        client = self.create_client(AddTwoInts, 'add_two_ints')",
#        "        client_info: ClientInfo = (client, 'add_two_ints')",
#        "        self._clients[id(client)] = ",
#        "",
#    ])
#        
#    # Create the AgentNode callback methods:
#    agent_lines.extend([
#        "    def service_availability_callback(self) -> None:",
#        f"       {quote3}Timere callback for checking service availablity.{quote3}",
#        "        print('')",
#        "",
#        "    def callback1(self, msg: String) -> None:",
#        "        print(f'callback1(\"{msg.data}\")')",
#        "        msg2: String = String()",
#        "        msg2.data = f'<{msg.data}>'",
#        "        self._publications['topic2'].publish(msg2)",
#        "",
#        "    def callback2(self, msg: String) -> None:",
#        "        print(f'callback2(\"{msg.data}\")')"
#        "",
#    ])
#
#    # Generate main():
#    agent_lines.extend([
#        "def main(args: Optional[List[str]] = None) -> None:",
#        "    # Initialize the Python ROS2 interface library.",
#        "    rclpy.init(args=args)",
#        "",
#        "    # Create the agent Node.",
#        "    agent_node: AgentNode = AgentNode()",
#        "",
#        "    # Start the agent Node.  All activity occurs via callback routines.",
#        "    rclpy.spin(agent_node)",
#        "",
#        "    # Destroy the node explicitly.",
#        "    agent_node.destroy_node()",
#        "",
#        "    # Shut down the Python ROS2 interface library.",
#        "    rclpy.shutdown()",
#        "",
#    ])
#
#    # Generate main function call:
#    agent_lines.extend([
#        "if __name__ == '__main__':",
#        "    main(args=None)",
#    ])
#
#    # Convert *agent_lines* into a single *agent_content* string:
#    agent_lines.append("")
#    agent_content: str = "\n".join(agent_lines)
#
#    # Write *agent_content* out to *agent_path* file:
#    agent_path: Path = python_package_directory / f"serial_agent.py"
#    agent_file: IO[str]
#    with open(agent_path, "w") as agent_file:
#        agent_file.write(agent_content)

def resource_create(ros2_package_directory: Path, package_name: str) -> None:
    """Create the resource directory an fill it in."""
    resource_directory: Path = ros2_package_directory / "resource"
    resource_directory.mkdir(parents=True, exist_ok=True)

    # Write out an empty file:
    resource_package_path: Path = resource_directory / package_name
    resource_package_file: IO[str]
    with open(resource_package_path, "w") as resource_package_file:
        pass

def setup_py_create(ros2_package_directory: Path, package_name: str) -> None:
    """Create the `setup.py` file. """
    email: str = email_get()
    maintainer: str = maintainer_get()
    setup_py_lines: Tuple[str, ...] = (
        "from setuptools import setup",
        "",
        f"package_name = '{package_name}'",
        "",
        "setup(",
        "    name=package_name,",
        "    version='0.0.0',",
        "    packages=[package_name],",
        "    data_files=[",
        "        ('share/ament_index/resource_index/packages',",
        "            ['resource/' + package_name]),",
        "        ('share/' + package_name, ['package.xml']),",
        "    ],",
        "    install_requires=['setuptools'],",
        "    zip_safe=True,",
        f"    maintainer='{maintainer}',",
        f"    maintainer_email='{email}',",
        "    description='ROS2 Serial line package',",
        "    license='MIT',",
        "    tests_require=['pytest'],",
        "    entry_points={",
        "        'console_scripts': [",
        f"            'serial_agent = {package_name}.serial_agent:main',",
        "        ],",
        "    },",
        ")",
        "",
    )
    setup_py_content: str ="\n".join(setup_py_lines)

    # Write *setup_py_lines_content* to *setup_py_path:
    setup_py_path: Path = ros2_package_directory / "setup.py"
    setup_py_file: IO[str]
    with open(setup_py_path, "w") as setup_py_file:
        setup_py_file.write(setup_py_content)

def package_xml_create(ros2_package_directory: Path, package_name: str) -> None:
    """Create the `package.xml` file."""
    # Get the *maintainer* and *email*:
    email: str = email_get()
    maintainer: str = maintainer_get()

    # Create the *package_xml_text* content.  Use single quotes for strings since XML
    # files tend to use double quotes a lot:
    package_xml_lines: Tuple[str, ...] = (
        '<?xml version="1.0"?>',
        ('<?xml-model href="http://download.ros.org/schema/package_format3.xsd"'
         ' schematypens="http://www.w3.org/2001/XMLSchema"?>'),
        '<package format="3">',
        f'  <name>{package_name}</name>',
        '  <version>0.0.0</version>',
        '  <description>Package for interacting with serial line.</description>',
        f'  <maintainer email="{email}">{maintainer}</maintainer>',
        '  <license>MIT</license>',
        '  <exec_depend>rclpy</exec_depend>',
        '  <exec_depend>std_msgs</exec_depend>',
        '',
        '  <test_depend>ament_copyright</test_depend>',
        '  <test_depend>ament_flake8</test_depend>',
        '  <test_depend>ament_pep257</test_depend>',
        '  <test_depend>python3-pytest</test_depend>',
        '',
        '  <export>',
        '    <build_type>ament_python</build_type>',
        '  </export>',
        '</package>',
        ''
    )
    package_xml_content: str = "\n".join(package_xml_lines)

    # Write out the *package_xml_content* to the `package.xml` file:
    package_xml_path: Path = ros2_package_directory / "package.xml"
    package_xml_file: IO[str]
    with open(package_xml_path, "w") as package_xml_file:
        package_xml_file.write(package_xml_content)

def init_py_create(python_package_directory: Path) -> None:
    """Create the empty `__init__.py` file."""
    init_py_path: Path = python_package_directory / "__init__.py"
    init_py_file: IO[str]
    with open(init_py_path, "w") as init_py_file:
        pass  # An empty file is what is desired


def setup_cfg_create(ros_package_directory: Path, package_name: str) -> None:
    """Create the `setup.cfg` file."""
    # Create the *setup_cfg_content*:
    setup_cfg_lines: Tuple[str, ...] = (
        "[develop]",
        f"script-dir=$base/lib/{package_name}",
        "[install]",
        f"install-scripts=$base/lib/{package_name}",
        "",
    )
    setup_cfg_content: str = "\n".join(setup_cfg_lines)

    # Write *setup_cfg_content* to *set_up_cfg_file*:
    setup_cfg_path: Path = ros_package_directory / "setup.cfg"
    setup_cfg_file: IO[str]
    with open(setup_cfg_path, "w") as setup_cfg_file:
        setup_cfg_file.write(setup_cfg_content)

def email_get() -> str:
    """Return the maintainer E-mail from git."""
    done: subprocess.CompletedProcess = subprocess.run(
        ["git", "config", "--get", "user.email"], capture_output=True, encoding="UTF-8")
    assert done.returncode == 0, "git config --get user.name has error code of {done.returncode}"
    return done.stdout.strip("\n")


def maintainer_get() -> str:
    """Return the maintainer name from git."""
    done: subprocess.CompletedProcess = subprocess.run(
        ["git", "config", "--get", "user.name"], capture_output=True, encoding="UTF-8")
    assert done.returncode == 0, "git config --get user.name has error code of {done.returncode}"
    return done.stdout.strip("\n")



if __name__ == "__main__":
    main()

# [Multiple futures await](https://stackoverflow.com/questions/46785274/asyncio-speculatively-await-multiple-futures)

#   client = MinimalClientAsync()
#   while rclpy.ok():
#       rclpy.spin_once()
#       response_futures: List[asyncio.Future] = 
#       done_futures: List[asyncio.Future]
#       pending_futures: List[asyncio.Future]
#       done_futures, pending_futures = (
#           await asyncio.wait(response_futures, return_when=FIRST_COMPLETED))
#       # Ignore pending_futures
#       done_future: asyncio.Future
#       for done_future in done_futures:
#            try:
#                response = done_future.result()
#            except Exception as e:
#                # Remove from all_futures
#                # do something error like here
#            else:
#                # Remove from all_futures
#                # Response is valid here
#                # Do someithing with response

# request = example_interfaces.srv._add_two_ints.AddTwoInts_Request(1, 2)
# request.get_fields_and_types()  => {'a': 'int64', 'b': 'int64'}
#
# response = example_interfaces.srv._add_two_ints.AddTwoInts_Response()
# response.get_fields_and_types() => {'sum': 'int64'}
